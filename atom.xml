<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>買銀杏只會忘了吃</title>
  
  <subtitle>記性不好，還是寫起來好惹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.killtw.im/"/>
  <updated>2020-02-20T03:37:52.332Z</updated>
  <id>https://blog.killtw.im/</id>
  
  <author>
    <name>Karl Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Whenever with Capistrano 3</title>
    <link href="https://blog.killtw.im/whenever-with-capistrano-3/"/>
    <id>https://blog.killtw.im/whenever-with-capistrano-3/</id>
    <published>2017-10-20T04:09:42.000Z</published>
    <updated>2020-02-20T03:37:52.332Z</updated>
    
    <content type="html"><![CDATA[<p>最近在五倍的 Rails 案子中碰到了使用 <a href="http://capistranorb.com/" target="_blank" rel="noopener">Capistrano</a> 部屬中，<code>bundle exec whenever</code> 會一直出現 <code>bundle: command not found</code> 的問題，跟同事檢查了一陣子都找不到問題所在。</p><p>由於專案的需求，Ruby 的路徑是使用環境變數來設定，一般而言在其他 command 都能順利執行的情況下應該是不會出現這樣的問題，唯一能想到的就是可能在執行的時候沒有吃到自訂的環境變數，在 Capistrano 中是使用 <code>set :default_env</code> 來設定環境變數，在檢查程式碼的時候發現是 <a href="https://github.com/javan/whenever" target="_blank" rel="noopener">whenever</a> 執行的過程中根本沒有去讀取自訂的環境變數</p><a id="more"></a><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set <span class="symbol">:whenever_command_environment_variables</span>, -&gt;&#123; &#123; <span class="symbol">rails_env:</span> fetch(<span class="symbol">:whenever_environment</span>) &#125; &#125;</span><br></pre></td></tr></table></figure><p>其實這個問題的解決辦法也很簡單，就是把原本設定的環境變數加到 <code>whenever_command_environment_variables</code> 裡頭讓他在執行時可以吃到，關於這個部分我已經發了 PR 就看 owner 什麼時候想要解決，而短期的作法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set <span class="symbol">:whenever_command_environment_variables</span>, -&gt; &#123; fetch(<span class="symbol">:default_env</span>).merge!(<span class="symbol">rails_env:</span> fetch(<span class="symbol">:whenever_environment</span>)) &#125;</span><br></pre></td></tr></table></figure><p>把以上這一段加入到 <code>deploy.rb</code> 中或是 stage 的設定檔中就可以了。<br>嗯，寫完了一篇費文呢✌️</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在五倍的 Rails 案子中碰到了使用 &lt;a href=&quot;http://capistranorb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Capistrano&lt;/a&gt; 部屬中，&lt;code&gt;bundle exec whenever&lt;/code&gt; 會一直出現 &lt;code&gt;bundle: command not found&lt;/code&gt; 的問題，跟同事檢查了一陣子都找不到問題所在。&lt;/p&gt;
&lt;p&gt;由於專案的需求，Ruby 的路徑是使用環境變數來設定，一般而言在其他 command 都能順利執行的情況下應該是不會出現這樣的問題，唯一能想到的就是可能在執行的時候沒有吃到自訂的環境變數，在 Capistrano 中是使用 &lt;code&gt;set :default_env&lt;/code&gt; 來設定環境變數，在檢查程式碼的時候發現是 &lt;a href=&quot;https://github.com/javan/whenever&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;whenever&lt;/a&gt; 執行的過程中根本沒有去讀取自訂的環境變數&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ruby" scheme="https://blog.killtw.im/tags/ruby/"/>
    
      <category term="rails" scheme="https://blog.killtw.im/tags/rails/"/>
    
      <category term="capistrano" scheme="https://blog.killtw.im/tags/capistrano/"/>
    
      <category term="whenever" scheme="https://blog.killtw.im/tags/whenever/"/>
    
  </entry>
  
  <entry>
    <title>Artist meets RubyKaigi</title>
    <link href="https://blog.killtw.im/artist-meet-rubykaigi/"/>
    <id>https://blog.killtw.im/artist-meet-rubykaigi/</id>
    <published>2017-10-06T06:48:53.000Z</published>
    <updated>2020-02-20T03:37:52.268Z</updated>
    
    <content type="html"><![CDATA[<p>前一陣子離開待了兩年多的 <a href="https://www.flyingv.cc" target="_blank" rel="noopener">flyingV</a>，休息了一陣子之後加入在台灣經營 Ruby 社群已久的 <a href="https://5xruby.tw" target="_blank" rel="noopener">五倍紅寶石</a>，加入後剛好碰上五倍的員工旅遊，考慮手邊還有一點日幣應該不會花太多錢的狀況下就跟團了。</p><h2 id="RubyKaigi"><a href="#RubyKaigi" class="headerlink" title="RubyKaigi?"></a>RubyKaigi?</h2><p><a href="http://rubykaigi.org" target="_blank" rel="noopener">RubyKaigi</a> 是日本最大的 Ruby 研討會，Kaigi 就是日文 <code>會議</code> 的意思，從 2006 年舉辦至今都是連續兩到三天的活動，同時每年也都會在日本境內不同的城市舉行，例如 <a href="(http://rubykaigi.org/2015">2015</a> 是在東京、<a href="http://rubykaigi.org/2016" target="_blank" rel="noopener">2016</a> 在京都、今年在廣島。</p><a id="more"></a><h2 id="議程"><a href="#議程" class="headerlink" title="議程"></a>議程</h2><p>RubyKaigi 的議程主要是比較偏向 Ruby 語言本身，應用的部分比較少做討論，大多都是探討語言的使用以及改進，不過也是會有像 <a href="http://rubykaigi.org/2017/presentations/anton_davydov.html" target="_blank" rel="noopener">Hanami - New Ruby Web Framework</a> 或是 <a href="http://rubykaigi.org/2017/presentations/lctseng.html" target="_blank" rel="noopener">Tamashii - Create Rails IoT applications more easily</a> 這類應用層面的議程。<br>也因為這個原因，跟 Ruby 很不熟的我只能挑一些看起來應該勉強的聽懂的場次，不過最後還是因為真的聽不懂而放棄</p><p><img src="/artist-meet-rubykaigi/matz.jpg" alt="與 Ruby 之父 Matz 合照"></p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>這次參加 RubyKaigi 最讓我驚艷的部分應該就是在交流的部份了，不知道是不是 RubyKaigi 的傳統，總之從活動前一天開始就有 Party，每天議程結束之後也都會有廠商贊助的 <del>酒會</del> 活動。<br>由於 Pre-Party 當天遇到颱風登陸加上沒搶到票的關係，很可惜的沒有參加到以外，每天的活動都有參與到，見識到有別於台灣一些研討會的部份。</p><ul><li>Day 1 官方 Party<br>原先是需要預先報名的活動，不過開始之後官方好像也沒有審查，所以就莫名變成超多人的活動，其中印象最深刻的部份大概就是木製的清酒方杯了吧</li></ul><p><img src="/artist-meet-rubykaigi/cup.png" alt="清酒方杯"></p><p>在活動中也跟不少來自世界各地的 Ruby 開發者們聊天，雖然語言有點障礙，不過整體上的氣氛相當愉快，還見識到了五倍吸怪機的能耐！</p><ul><li><p>Day 2 ESM 贊助酒會<br>據公司同事表示，只要是 ESM 的活動，參加就對了！去到現場就會知道此話不假，包下酒吧之後直接擺出近 20 種的清酒任君挑選，喝不夠還有啤酒、軟性飲料跟一直冒出來的食物可以選擇。<br>雖然跟第一天官方的活動比起來場地較小、人也比較少，不過也因為這樣可以更方便跟人聊天，拿著清酒跟人對飲之後就可以開始交流，也算是滿有趣的一次經驗。<br><img src="/artist-meet-rubykaigi/sake.jpg" alt="清酒排排站"></p></li><li><p>Day 2 Shopify 卡拉 OK<br>緊接在 ESM 酒會之後的二次會是由 Shopify 贊助的卡拉 OK 活動，沒有去唱過日K的本人想說應該去見識一下世面，沒想到就這樣被推下坑唱了一首（艸），完全沒有日語能力的狀況下要好好的唱完一首歌真的很困難阿，不像同事那麼得心應手。<br><img src="/artist-meet-rubykaigi/ryudoawaru.jpg" alt="總招"><br><img src="/artist-meet-rubykaigi/karaoke.gif" alt="日本人唱起歌來真的是很有趣"></p></li><li><p>Day 3 官方 After Party<br>全部議程結束之後官方在當地的 SOGO 頂樓舉辦了官方的 After Party，餐飲都是無限量供應，加上不需要報名所以來了非常多的人，可以見到許多講者以及 Ruby committer，可惜場地是一堆桌椅的形式，交流起來稍有困難，不過後來發現站在啤酒機前可以很輕易的跟人聊天😂<br><img src="/artist-meet-rubykaigi/booth.jpg" alt="像攤位的食物們"></p></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>不知道是只有 RubyKaigi 這樣子還是國外的研討會都是這樣，總之讓我見識到不同的交流模式，今年 <a href="https://laravelconf.tw/zh-TW" target="_blank" rel="noopener">LaravelConf</a> 也有在會後舉辦類似的交流會，不過相較之下不管是在規模或是形式都相差甚遠，PHPConf 的話就更不用講了，<del>有時候連議程都很懶得進去聽</del><br>可能是國情或是文化的關係，又或者是因為與會者大多都是本國人，在台灣的我參加過的研討會不曉得為什麼都會變得有點在上課的感覺，最重要的「交流」反而變得不是那麼重要，希望這次參加 RubyKaigi 的經驗可以為往後的活動帶來一點不一樣的刺激。<br>最後還是要感謝一下公司五倍紅寶石能讓我們參加這樣子的活動，雖然因為加入公司的時間不長所以花了不少自費款，不過我相信是值得的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一陣子離開待了兩年多的 &lt;a href=&quot;https://www.flyingv.cc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;flyingV&lt;/a&gt;，休息了一陣子之後加入在台灣經營 Ruby 社群已久的 &lt;a href=&quot;https://5xruby.tw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五倍紅寶石&lt;/a&gt;，加入後剛好碰上五倍的員工旅遊，考慮手邊還有一點日幣應該不會花太多錢的狀況下就跟團了。&lt;/p&gt;
&lt;h2 id=&quot;RubyKaigi&quot;&gt;&lt;a href=&quot;#RubyKaigi&quot; class=&quot;headerlink&quot; title=&quot;RubyKaigi?&quot;&gt;&lt;/a&gt;RubyKaigi?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://rubykaigi.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RubyKaigi&lt;/a&gt; 是日本最大的 Ruby 研討會，Kaigi 就是日文 &lt;code&gt;會議&lt;/code&gt; 的意思，從 2006 年舉辦至今都是連續兩到三天的活動，同時每年也都會在日本境內不同的城市舉行，例如 &lt;a href=&quot;(http://rubykaigi.org/2015&quot;&gt;2015&lt;/a&gt; 是在東京、&lt;a href=&quot;http://rubykaigi.org/2016&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2016&lt;/a&gt; 在京都、今年在廣島。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Ruby" scheme="https://blog.killtw.im/tags/Ruby/"/>
    
      <category term="RubyKaigi" scheme="https://blog.killtw.im/tags/RubyKaigi/"/>
    
      <category term="RubyKaigi2017" scheme="https://blog.killtw.im/tags/RubyKaigi2017/"/>
    
      <category term="5xRuby" scheme="https://blog.killtw.im/tags/5xRuby/"/>
    
  </entry>
  
  <entry>
    <title>Yarn global add with nvm</title>
    <link href="https://blog.killtw.im/yarn-global-add-with-nvm/"/>
    <id>https://blog.killtw.im/yarn-global-add-with-nvm/</id>
    <published>2017-06-21T06:49:33.000Z</published>
    <updated>2020-02-20T03:37:52.332Z</updated>
    
    <content type="html"><![CDATA[<p>昨天心血來潮想說把 Blog 搬回 Github 上省下 linode 的費用時，發現 <code>hexo-cli</code> 由於用 nvm 裝了不同版本 node 沒有裝回 global packages 而不存在，這時只能重新安裝一次。</p><p>自從有了 yarn 之後就很少在用 npm 安裝 package，所以就很順手的輸入了 <code>yarn global add hexo-cli</code>，安裝的過程很順利，不過在執行 <code>hexo</code> 時卻發現一直出現 <code>command not found: hexo</code> 的訊息，到處找也都找不到究竟安裝到哪裡去，查了一下資料也沒有找到發生的原因。</p><p>後來在 Github 上找到了三個解決方法，其中兩個的作法是指定 global bin 的安裝位置，另一個則是在 PATH 中增加路徑，選擇其一即可。</p><a id="more"></a><ol><li><a href="#global-folder">global-folder</a></li><li><a href="#config-prefix">config prefix</a></li><li><a href="#add-path">add path</a></li></ol><h2 id="global-folder"><a href="#global-folder" class="headerlink" title="global-folder"></a><a id="global-folder"></a>global-folder</h2><p>這個作法比較麻煩，因為每次要新增 global package 的時候都要在後面加上 <code>--global-folder=$(yarn global bin)</code>，當然也可以新增 alias 來達到相同目的。<br>比如說要安裝 <code>hexo-cli</code> 時就要輸入 <code>yarn global add hexo-cli --global-folder=$(yarn global bin)</code> 這樣。</p><h2 id="config-prefix"><a href="#config-prefix" class="headerlink" title="config prefix"></a><a id="config-prefix"></a>config prefix</h2><p>這個方式跟上面那個比起來相對簡單，而且只要作一次就可以，之後除非是安裝了不同版本的 node，不然不需要在做一次<br>直接執行 <code>yarn config set prefix $(npm config get prefix)</code> 之後再重新安裝 package 就可以發現執行檔安裝到了正確位置，並且可以執行了。</p><h2 id="add-path"><a href="#add-path" class="headerlink" title="add path"></a><a id="add-path"></a>add path</h2><p>後來發現這個方法比起上面兩個又更輕鬆，而且之後就算 node 版本有更動也不需要在做一次同樣動作<br>在你的 <code>.bashrc</code> 或是 <code>.zshrc</code> 等設定檔中的 PATH 部分加入 <code>yarn global bin</code> 的路徑，如下：<br><code>export PATH=&quot;$PATH:$HOME/.config/yarn/global/node_modules/.bin&quot;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天心血來潮想說把 Blog 搬回 Github 上省下 linode 的費用時，發現 &lt;code&gt;hexo-cli&lt;/code&gt; 由於用 nvm 裝了不同版本 node 沒有裝回 global packages 而不存在，這時只能重新安裝一次。&lt;/p&gt;
&lt;p&gt;自從有了 yarn 之後就很少在用 npm 安裝 package，所以就很順手的輸入了 &lt;code&gt;yarn global add hexo-cli&lt;/code&gt;，安裝的過程很順利，不過在執行 &lt;code&gt;hexo&lt;/code&gt; 時卻發現一直出現 &lt;code&gt;command not found: hexo&lt;/code&gt; 的訊息，到處找也都找不到究竟安裝到哪裡去，查了一下資料也沒有找到發生的原因。&lt;/p&gt;
&lt;p&gt;後來在 Github 上找到了三個解決方法，其中兩個的作法是指定 global bin 的安裝位置，另一個則是在 PATH 中增加路徑，選擇其一即可。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="node" scheme="https://blog.killtw.im/tags/node/"/>
    
      <category term="nvm" scheme="https://blog.killtw.im/tags/nvm/"/>
    
      <category term="yarn" scheme="https://blog.killtw.im/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>Cloudflare with nginx: Too many redirects</title>
    <link href="https://blog.killtw.im/cloudflare-nginx-too-many-redirects/"/>
    <id>https://blog.killtw.im/cloudflare-nginx-too-many-redirects/</id>
    <published>2016-08-05T05:04:43.000Z</published>
    <updated>2020-02-20T03:37:52.328Z</updated>
    
    <content type="html"><![CDATA[<p>最近在試著將 blog 利用 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare</a> 加上 CDN 的時候發現如果開啟 SSL 的功能時會發生如首圖 <strong>Too many redirects</strong> 的錯誤，研究了一下發現是因為 Cloutflare 搭配 nginx 時在某些情況下會產生這種狀況，也找到了幾種方式來解決這惱人的問題。</p><a id="more"></a><p>在研究的過程中我一共找到三種不同的解法，基本上都不用去動到 nginx 的設定，分別是</p><ol><li><a href="#strict">全面 strict 法</a></li><li><a href="#force-https">強制 https 法</a></li><li><a href="#page-rule-strice">Page Rule strict 法</a></li></ol><p>以下會做些簡單的步驟說明來介紹這三種方式要怎麼解決 <strong>Too many redirects</strong> 的問題</p><h2 id="全面-strict-法"><a href="#全面-strict-法" class="headerlink" title="全面 strict 法"></a><a id="strict"></a>全面 strict 法</h2><p>如果你的 server 上原本就已經有 SSL 憑證的話，這應該是最無腦的方法了，只需要將 <strong>Crypto</strong> 裡頭的 SSL 設定從 Flexible 改成 Full(strict) 即可</p><p><img src="/cloudflare-nginx-too-many-redirects/strict.png" alt="將 SSL 改為 Full(strict)"></p><h2 id="強制-https-法"><a href="#強制-https-法" class="headerlink" title="強制 https 法"></a><a id="force-https"></a>強制 https 法</h2><p>另外一個方式就是強制所有使用者在進入網站的時候都使用 https 的方式，Cloudflare 在這部份也有相當簡單的設置方法：</p><ol><li>點選上方的 <strong>Page Rules</strong><br><img src="/cloudflare-nginx-too-many-redirects/page-rules.png" alt="Page Rules"></li><li>Create Page Rule</li><li>照著下圖選擇 <strong>Always Use HTTPS</strong>，網址的部份則是填入你希望使用 https 的網址並再後面加上星號來動態使用<br><img src="/cloudflare-nginx-too-many-redirects/force-https.png" alt="將網址強制使用 https"></li></ol><h2 id="Page-Rule-strict-法"><a href="#Page-Rule-strict-法" class="headerlink" title="Page Rule strict 法"></a><a id="page-rule-strice"></a>Page Rule strict 法</h2><p>這個方法是結合了上面兩種來達成 HTTPS(strict)，利用 Page Rules 來針對特定網址將他改為 HTTPS(strict)，設定的方式也跟 <a href="#force-https">強制 https 法</a> 相當類似<br>基本上的作法就是建個新的 Page Rule，然後將 SSL 改為 strict<br><img src="/cloudflare-nginx-too-many-redirects/page-rules-strict.png" alt="選擇 strice"><br>這樣子就不會影響到其他的 subdomain 進而產生其他問題了</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>基本上會發生這個問題是因為用 Flexible SSL 時，使用者進入到你的網站，nginx 還是會把它視為 http，如果你的 nginx 沒有特別判斷就轉址至 https 時就會產生無限迴圈<br>這三個方法中我自己是選用 <a href="#page-rule-strice">Page Rule strict 法</a>，沒有什麼特別的原因，就只是想說既然有三個 Page Rule 的額度那就來用一下吧XD<br>如果你想從 nginx 那邊下手的話，可以用 <code>$http_x_forwarded_proto</code> 去判斷來源究竟是 http 還是 https 之後再進行轉址處理</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在試著將 blog 利用 &lt;a href=&quot;https://www.cloudflare.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cloudflare&lt;/a&gt; 加上 CDN 的時候發現如果開啟 SSL 的功能時會發生如首圖 &lt;strong&gt;Too many redirects&lt;/strong&gt; 的錯誤，研究了一下發現是因為 Cloutflare 搭配 nginx 時在某些情況下會產生這種狀況，也找到了幾種方式來解決這惱人的問題。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ssl" scheme="https://blog.killtw.im/tags/ssl/"/>
    
      <category term="cloudflare" scheme="https://blog.killtw.im/tags/cloudflare/"/>
    
      <category term="nginx" scheme="https://blog.killtw.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Valet with Docker</title>
    <link href="https://blog.killtw.im/laravel-valet-with-docker/"/>
    <id>https://blog.killtw.im/laravel-valet-with-docker/</id>
    <published>2016-06-29T03:41:43.000Z</published>
    <updated>2020-02-20T03:37:52.332Z</updated>
    
    <content type="html"><![CDATA[<p>前一陣子 <a href="https://laravel.com/" target="_blank" rel="noopener">Laravel</a> 官方推出了輕量化的開發環境解決方案 <a href="https://laravel.com/docs/master/valet" target="_blank" rel="noopener">Valet</a>，他跟 <a href="https://laravel.com/docs/master/homestead" target="_blank" rel="noopener">Homestead</a> 最大的不同在於他不是一個完整的 VM，基本上他只有用 Caddy 作為 Web Server 以及 Dnsmasq 來管理網址，也因為使用 Caddy 的關係，所以目前支援的系統只有 Mac。</p><a id="more"></a><p>由於輕量化的設計，Valet 並未包含任何 Database 跟程式語言，所以這部份我想到應該可以用 <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> 來簡單的處理掉，就順手研究了一下作法，接下來會根據以下步驟進行。</p><ol><li><a href="#install-homebrew">Install Homebrew</a></li><li><a href="#install-composer">Install Composer</a></li><li><a href="#install-valet">Install Valet</a></li><li><a href="#install-docker-for-mac">Install Docker for Mac</a></li><li><a href="#docker-config">Docker config</a></li></ol><h2 id="Install-Homebrew"><a href="#Install-Homebrew" class="headerlink" title="Install Homebrew"></a><a id="install-homebrew"></a>Install Homebrew</h2><p><a href="http://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 可以說是目前 Mac 上最方便的 Package Management 方案，我自己是連 App 的部份都會透過 Homebrew cask 來安裝，這樣每次重新安裝電腦的時候都可以直接透過一個指令安裝完所有的軟體。<br>安裝的步驟也非常簡單，只需要執行下面的 script 就能完成安裝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><h2 id="Install-Composer"><a href="#Install-Composer" class="headerlink" title="Install Composer"></a><a id="install-composer"></a>Install Composer</h2><p><a href="https://getcomposer.org/" target="_blank" rel="noopener">Composer</a> 是 PHP 的 Dependency Manager，在 Packagist 上有許多開源的套件可以供大家使用，Laravel 以及接下來會用到 Valet 都可以在上面找到並使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">"copy('https://getcomposer.org/installer', 'composer-setup.php');"</span> <span class="comment">#下載 Composer Setup script</span></span><br><span class="line">php -r <span class="string">"if (hash_file('SHA384', 'composer-setup.php') === 'e115a8dc7871f15d853148a7fbac7da27d6c0030b848d9b3dc09e2a0388afed865e6a3d6b3c0fad45c48e2b5fc1196ae') &#123; echo 'Installer verified'; &#125; else &#123; echo 'Installer corrupt'; unlink('composer-setup.php'); &#125; echo PHP_EOL;"</span> <span class="comment">#驗證 SHA-384</span></span><br><span class="line">php composer-setup.php <span class="comment">#執行安裝</span></span><br><span class="line">php -r <span class="string">"unlink('composer-setup.php');"</span> <span class="comment">#移除 composer-setup.php</span></span><br></pre></td></tr></table></figure><p>安裝完之後建議執行以下 script 方便之後使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv composer.phar /usr/<span class="built_in">local</span>/bin/composer</span><br></pre></td></tr></table></figure><p>最後在你的 <code>.bashrc</code> 或是 <code>.zhsrc</code> 內中加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/.composer/vendor/bin"</span></span><br></pre></td></tr></table></figure><p>這樣子系統才有辦法知道 Composer package 的路徑以便使用。</p><h2 id="Install-Valet"><a href="#Install-Valet" class="headerlink" title="Install Valet"></a><a id="install-valet"></a>Install Valet</h2><p>上面講到 Valet 屬於 Composer package，所以他的安裝是需要透過 Composer 指令來進行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require laravel/valet</span><br></pre></td></tr></table></figure><p>安裝完 Package 之後執行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valet install</span><br></pre></td></tr></table></figure><p>進行 Valet 的安裝動作，安裝過程中 Valet 會幫你透過 Homebrew 安裝 PHP 7.0 以及其他相關套件。</p><h2 id="Install-Docker-for-Mac"><a href="#Install-Docker-for-Mac" class="headerlink" title="Install Docker for Mac"></a><a id="install-docker-for-mac"></a>Install Docker for Mac</h2><p>到這邊為止 Valet 已經算是安裝完成了，你可以查看 <a href="https://laravel.com/docs/master/valet" target="_blank" rel="noopener">官方文件</a> 來了解 Valet 的使用方式。<br>接下來我們會進行 Docker 的安裝，目前 <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker for Mac</a> 還處於 public beta 的階段，所以大家可以自行斟酌要不要使用XD，安裝方法也很簡單，只需要將 <a href="https://download.docker.com/mac/beta/Docker.dmg" target="_blank" rel="noopener">https://download.docker.com/mac/beta/Docker.dmg</a> 下載之後正常安裝即可。<br>安裝完基本上不需設定，執行之後就可以看到 Docker 已經啟動，不過你還是可以針對 Cpu 以及記憶體的部份自行設定，一般是照預設就很夠用了。</p><h2 id="Docker-config"><a href="#Docker-config" class="headerlink" title="Docker config"></a><a id="docker-config"></a>Docker config</h2><p>目前我在 Docker 裡頭配置了 MariaDB、Redis 以及 Elasticsearch，語言的部份則有 NodeJS 以及 Ruby。<br>安裝方法也不難，基本上也只有幾個步驟而已：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/killtw/docker.git</span><br></pre></td></tr></table></figure><p>假如你的系統沒有 <code>git</code> 的話也可以透過 <code>https://github.com/killtw/docker/archive/master.zip</code> 下載之後解壓縮使用。<br><code>git clone</code> 或解壓縮之後在目錄內執行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d redis mariadb elasticsearch</span><br></pre></td></tr></table></figure><p>這樣就會將 MariaDB、Redis、Elasticsearch 跑起來，假如你有不需要的服務的話在指令中將他拿掉就可以了。<br>預設的帳號密碼可以從 <code>docker-compose.yml</code> 中修改。</p><p>語言的使用部份有兩種方式，一是直接執行指令，二則需要在 <code>.bashrc</code> 或 <code>.zshrc</code> 中加入 <code>alias</code> 來使用：</p><h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v $(PWD):/workspace killtw/workspace node</span><br></pre></td></tr></table></figure><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v $(PWD):/workspace killtw/workspace npm</span><br></pre></td></tr></table></figure><p>基本上就是最後在改變，目前可以是用的有 <code>node, npm, gulp, bower, ruby</code><br>假如不想每次都打那麼長的指令的話，可以在 <code>.bashrc</code> 或 <code>.zshrc</code> 中加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> node=<span class="string">"docker run -it --rm -v <span class="variable">$(PWD)</span>:/workspace killtw/workspace node"</span></span><br></pre></td></tr></table></figure><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>基本上這樣子該有的東西都有了，就可以開心的開發 Laravel Application 啦～<br>Docker 的部份還不是很熟，而且用法也跟官方比較推薦的 per project 不太一樣，如果大家有更好的作法的話歡迎告訴我，或是直接在 <a href="https://github.com/killtw/docker" target="_blank" rel="noopener">Github</a> 開 issue 給我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一陣子 &lt;a href=&quot;https://laravel.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Laravel&lt;/a&gt; 官方推出了輕量化的開發環境解決方案 &lt;a href=&quot;https://laravel.com/docs/master/valet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Valet&lt;/a&gt;，他跟 &lt;a href=&quot;https://laravel.com/docs/master/homestead&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Homestead&lt;/a&gt; 最大的不同在於他不是一個完整的 VM，基本上他只有用 Caddy 作為 Web Server 以及 Dnsmasq 來管理網址，也因為使用 Caddy 的關係，所以目前支援的系統只有 Mac。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="laravel" scheme="https://blog.killtw.im/tags/laravel/"/>
    
      <category term="php" scheme="https://blog.killtw.im/tags/php/"/>
    
      <category term="docker" scheme="https://blog.killtw.im/tags/docker/"/>
    
  </entry>
  
</feed>
